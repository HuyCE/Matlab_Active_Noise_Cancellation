clear all; close all;
% Masked noise as sin signal
% total_time = 10; % [s]
% sampling_rate = 100; % [Hz]
% amplitude = 1;
% signal_freq = 10; % Hz
% sampling_sequence = 0:1/sampling_rate:total_time;
% 
% noise_wave = amplitude * sin(2*pi*signal_freq*sampling_sequence);

%                  +------------------+
%  Input Signal -->|     Processor    |--> Output Signal
%                  |                  |
%                  +------------------+
%
%
%
%           +----------------------------+
%           |                            |
%           |   Feedback System Example  |
%           |                            |
%           +------------v---------------+
%                        |
%                        | Error
%                        V
%                  +------------------+
%  Reference ---->O-|    Controller    |----+-----> Output
%                  ^  +------------------+    |
%                  |                           |
%                  |                           |
%                  +-------[ Sensor ]----------+
%
%
%
%                  +---------------------+
%                  |                     |
%                  |      Summing        |
%  Input 1 -------->+                     |
%                   |        Node         |----> Output
%  Input 2 -------->+                     |
%                  |                     |
%                  +---------------------+
%
%
%
%                  +---------------------+
%  Signal A ------->[ Block 1 ]----------->[ Block 2 ]-----------> Signal B
%                  |                     |
%                  +---------------------+
%
%plot(sampling_sequence,noise_wave)

% P(z) ~ Primary path, consist of acoustic response  the ref sensor to
% error sensor

% W(z) ~ adaptive filter estimate unknown plant P(z)

% S(z) ~ secondary-path transfer function from y(n) -> e(n), which includes
% the digital-to-analog (D/A) converter, reconstruction filter, 
% power amplifier, loudspeaker,
% acoustic path from loudspeaker to error microphone, error
% microphone, preamplifier, antialiasing filter, and analog-todigital (A/D) converter

% S^(z)

% e(n) ~ residual noise signal ~ e(n) = y(n) - d(n)

%% 1. System Parameters
Fs = 8000;              % Sampling frequency (Hz)
duration = 5;           % Simulation duration (seconds)
N = Fs * duration;      % Total number of samples

% Adaptive filter parameters
Lw = 128;               % Length of the adaptive (control) filter W(z)
mu_W = 0.005;           % Step size for updating W(z) - adjust for convergence/stability
                        % IMPORTANT: If the filter diverges (errors with NaN/Inf),
                        % REDUCE this value (e.g., to 0.001, 0.0005, etc.)

% Secondary path estimation filter parameters (C(z))
Lc = 64;                % Length of the secondary path estimation filter C(z)

%% 2. Simulate Acoustic Paths (Impulse Responses)

% --- Primary Path P(z) ---
primary_path_order = 50;
h_P = fir1(primary_path_order, 0.1 + 0.4*rand(1,1), 'low');
h_P = h_P / norm(h_P);
primary_path_delay = 10;
h_P = [zeros(1, primary_path_delay), h_P];

% --- Secondary Path S(z) ---
secondary_path_order = 40;
h_S = fir1(secondary_path_order, 0.2 + 0.3*rand(1,1), 'bandpass');
h_S = h_S / norm(h_S);
secondary_path_delay = 5;
h_S = [zeros(1, secondary_path_delay), h_S];

% Plot the simulated acoustic paths

% figure;
% subplot(2,1,1);
% stem(0:length(h_P)-1, h_P);
% title('Simulated Primary Path Impulse Response (P(z))');
% xlabel('Samples');
% ylabel('Amplitude');
% grid on;
% 
% subplot(2,1,2);
% stem(0:length(h_S)-1, h_S);
% title('Simulated Secondary Path Impulse Response (S(z))');
% xlabel('Samples');
% ylabel('Amplitude');
% grid on;

%% 3. Generate Signals

% --- Primary Noise Source (d_source) ---
f1 = 100; % Hz
f2 = 300; % Hz
t = (0:N-1)/Fs;
d_source = 0.5 * sin(2*pi*f1*t) + 0.3 * sin(2*pi*f2*t) + 0.1 * randn(1, N);

% --- Reference Signal (x) ---
x = d_source;

% Pre-allocate arrays for efficiency
e = zeros(1, N);            % Error signal at the error microphone
y = zeros(1, N);            % Anti-noise signal generated by the control filter W(z)
d = filter(h_P, 1, d_source); % Primary noise at the error microphone (pre-calculated)????
y_prime = zeros(1, N);      % Anti-noise signal after passing through the REAL secondary path S(z)

% Adaptive filter coefficients W(z)
W = zeros(1, Lw);           % Initialize adaptive filter weights to zeros

% Secondary path estimation filter C(z) coefficients
% For this bare-metal example, we are 'pre-estimating' the secondary path.
h_S_est = h_S + 0.1 * randn(size(h_S)) * max(abs(h_S)); % Add some noise to the true path
h_S_est(h_S_est < 0.01*max(abs(h_S_est))) = 0; % Small values to zero for cleaner plot
h_S_est = h_S_est / norm(h_S_est); % Normalize
if length(h_S_est) < Lc
    h_S_est = [h_S_est, zeros(1, Lc - length(h_S_est))];
else
    h_S_est = h_S_est(1:Lc);
end
C = h_S_est; % Use this as our pre-estimated secondary path for the FXLMS algorithm


% Plot Original generated noise and estimated secondary path
figure;
subplot(2,1,1);
plot(t,d_source);

subplot(2,1,2);
stem(0:length(C)-1, C);
title('Estimated Secondary Path Impulse Response (C(z))');
xlabel('Samples');
ylabel('Amplitude');
grid on;
%% 4. FXLMS Algorithm Implementation (Time Domain Loop)
