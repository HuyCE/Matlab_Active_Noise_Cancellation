% FXLMS Filter Bare-Metal Example in MATLAB
% This script simulates a single-channel active noise control (ANC) system
% using the Filtered-X Least Mean Squares (FXLMS) algorithm.
% This version removes the 'persistent' keyword for direct script execution.

% Clear workspace and command window
clear;
clc;
close all; % Close all figures

%% 1. System Parameters
[y_noise, Fs_noise] = audioread("noise.wav");
y_renoise = y_noise(1:length(y_noise),1);

Fs = Fs_noise;              % Sampling frequency (Hz)
duration = 5;           % Simulation duration (seconds)
N = length(y_renoise);      % Total number of samples
plot_numberOfSampler = linspace(0,length(y_renoise)/Fs_noise, length(y_renoise));

figure;
plot(plot_numberOfSampler, y_renoise)

% Adaptive filter parameters
Lw = 128;               % Length of the adaptive (control) filter W(z)
mu_W = 0.0001;           % Step size for updating W(z) - adjust for convergence/stability
                        % IMPORTANT: If the filter diverges (errors with NaN/Inf),
                        % REDUCE this value (e.g., to 0.001, 0.0005, etc.)

% Secondary path estimation filter parameters (C(z))
Lc = 64;                % Length of the secondary path estimation filter C(z)

%% 2. Simulate Acoustic Paths (Impulse Responses)

% --- Primary Path P(z) ---
primary_path_order = 50;
h_P = fir1(primary_path_order, 0.1 + 0.4*rand(1,1), 'low');
h_P = h_P / norm(h_P);
primary_path_delay = 10;
h_P = [zeros(1, primary_path_delay), h_P];

% --- Secondary Path S(z) ---
secondary_path_order = 40;
h_S = fir1(secondary_path_order, 0.2 + 0.3*rand(1,1), 'bandpass');
h_S = h_S / norm(h_S);
secondary_path_delay = 5;
h_S = [zeros(1, secondary_path_delay), h_S];

% Plot the simulated acoustic paths
% figure;
% subplot(2,1,1);
% stem(0:length(h_P)-1, h_P);
% title('Simulated Primary Path Impulse Response (P(z))');
% xlabel('Samples');
% ylabel('Amplitude');
% grid on;
% 
% subplot(2,1,2);
% stem(0:length(h_S)-1, h_S);
% title('Simulated Secondary Path Impulse Response (S(z))');
% xlabel('Samples');
% ylabel('Amplitude');
% grid on;

%% 3. Generate Signals

% --- Primary Noise Source (d_source) ---
% f1 = 100; % Hz
% f2 = 300; % Hz
t = (0:N-1)/Fs;
% d_source = 0.5 * sin(2*pi*f1*t) + 0.3 * sin(2*pi*f2*t) + 0.1 * randn(1, N);
d_source = y_renoise;

% --- Reference Signal (x) ---
x = d_source;

% Pre-allocate arrays for efficiency
e = zeros(1, N);            % Error signal at the error microphone
y = zeros(1, N);            % Anti-noise signal generated by the control filter W(z)
d = filter(h_P, 1, d_source); % Primary noise at the error microphone (pre-calculated)
y_prime = zeros(1, N);      % Anti-noise signal after passing through the REAL secondary path S(z)

% Adaptive filter coefficients W(z)
W = zeros(1, Lw);           % Initialize adaptive filter weights to zeros

% Secondary path estimation filter C(z) coefficients
% For this bare-metal example, we are 'pre-estimating' the secondary path.
h_S_est = h_S + 0.1 * randn(size(h_S)) * max(abs(h_S)); % Add some noise to the true path
h_S_est(h_S_est < 0.01*max(abs(h_S_est))) = 0; % Small values to zero for cleaner plot
h_S_est = h_S_est / norm(h_S_est); % Normalize
if length(h_S_est) < Lc
    h_S_est = [h_S_est, zeros(1, Lc - length(h_S_est))];
else
    h_S_est = h_S_est(1:Lc);
end
C = h_S_est; % Use this as our pre-estimated secondary path for the FXLMS algorithm


% Plot estimated secondary path
% figure;
% stem(0:length(C)-1, C);
% title('Estimated Secondary Path Impulse Response (C(z))');
% xlabel('Samples');
% ylabel('Amplitude');
% grid on;

%% 4. FXLMS Algorithm Implementation (Time Domain Loop)

fprintf('Starting FXLMS simulation...\n');

% Initialize buffers for signals used in convolution *outside* the loop.
% These variables will retain their state across iterations naturally.
w_buffer = zeros(1, Lw); % Buffer for x(n) to compute y(n) = W(z)*x(n)
c_buffer = zeros(1, Lc); % Buffer for x(n) to compute x'(n) = C(z)*x(n)

% Buffers for sample-by-sample convolution within the loop.
% These are now regular variables initialized once.
y_hist_secondary_path = zeros(1, length(h_S)); % For simulating y'(n) = S(z)*y(n)
x_hist_filtered_x = zeros(1, Lw);     % For the filtered reference signal x'(n)


for n = 1:N
    current_x = x(n);
    current_d = d(n);

    % --- Update buffers for adaptive filter input x(n) ---
    % Shift previous samples and add current sample
    w_buffer = [current_x, w_buffer(1:Lw-1)];
    c_buffer = [current_x, c_buffer(1:Lc-1)];

    % --- Compute anti-noise signal y(n) ---
    y(n) = dot(W, w_buffer);

    % --- Simulate anti-noise at error microphone y'(n) ---
    % y_prime(n) is y(n) passed through the REAL secondary path S(z).
    % Update buffer for secondary path simulation
    y_hist_secondary_path = [y(n), y_hist_secondary_path(1:end-1)];
    y_prime(n) = dot(h_S, y_hist_secondary_path);

    % --- Compute error signal e(n) ---
    % e(n) = d(n) + y'(n)
    e(n) = current_d + y_prime(n);

    % --- Check for divergence (NaN or Inf values) ---
    if any(isnan(W)) || any(isinf(W)) || isnan(e(n)) || isinf(e(n))
        fprintf('\n--- WARNING: Filter diverged at sample %d! ---\n', n);
        fprintf('This usually means the step size (mu_W) is too large.\n');
        fprintf('Try reducing mu_W (e.g., to 0.001, 0.0005, or smaller).\n');
        e(n:end) = NaN; % Mark remaining error samples as NaN
        break; % Exit the loop early
    end

    % --- Compute filtered reference signal x'(n) ---
    % x'(n) = C(z) * x(n) (convolution with estimated secondary path C)
    current_x_filtered_by_C = dot(C, c_buffer);

    % --- Update buffer for x_filtered_x (used in W update) ---
    % This buffer holds the last Lw samples of the filtered reference signal.
    x_hist_filtered_x = [current_x_filtered_by_C, x_hist_filtered_x(1:end-1)];

    % --- Update adaptive filter weights W(n) ---
    W = W - mu_W * e(n) * x_hist_filtered_x; % FXLMS update rule

    % Display progress
    if mod(n, Fs*0.5) == 0 % Every 0.5 seconds
        fprintf('Processing %d/%d samples (%.1f%%)\n', n, N, (n/N)*100);
    end
end
fprintf('FXLMS simulation finished.\n');

%% 5. Analyze Results

% Ensure no NaNs from divergence affect final calculations if loop broke early
valid_samples = find(~isnan(e), 1, 'last');
if isempty(valid_samples)
    fprintf('No valid samples for analysis due to immediate divergence.\n');
else
    d_for_analysis = d(1:valid_samples);
    e_for_analysis = e(1:valid_samples);
    t_for_analysis = t(1:valid_samples);

    % Calculate noise reduction (often measured in dB)
    initial_noise_power = mean(d_for_analysis.^2);
    residual_noise_power = mean(e_for_analysis.^2);

    if initial_noise_power > 0 && residual_noise_power >= 0
        noise_reduction_dB = 10 * log10(initial_noise_power / (residual_noise_power + eps)); % Add eps to avoid log(0)
    else
        noise_reduction_dB = -Inf; % Or handle as appropriate
    end
    fprintf('\nNoise Reduction: %.2f dB\n', noise_reduction_dB);

    % Plot original noise, anti-noise, and error signal
    figure;
    subplot(3,1,1);
    plot(t_for_analysis, d_for_analysis);
    title('Primary Noise at Error Microphone (d(n))');
    xlabel('Time (s)');
    ylabel('Amplitude');
    grid on;
    ylim([-max(abs(d))*1.1 max(abs(d))*1.1]);

    subplot(3,1,2);
    plot(t_for_analysis, y(1:valid_samples));
    title('Anti-Noise Signal (y(n)) generated by W(z)');
    xlabel('Time (s)');
    ylabel('Amplitude');
    grid on;
    ylim([-max(abs(y(1:valid_samples)))*1.1 max(abs(y(1:valid_samples)))*1.1]);

    subplot(3,1,3);
    plot(t_for_analysis, e_for_analysis);
    title(sprintf('Residual Error Signal (e(n)) - Noise Reduction: %.2f dB', noise_reduction_dB));
    xlabel('Time (s)');
    ylabel('Amplitude');
    grid on;
    ylim([-max(abs(d))*1.1 max(abs(d))*1.1]); % Scale to original noise for comparison

    % Plot convergence of adaptive filter weights (optional, useful for debugging)
    figure;
    stem(0:Lw-1, W);
    title('Final Adaptive Filter Coefficients (W(z))');
    xlabel('Tap Index');
    ylabel('Coefficient Value');
    grid on;

    % Plot frequency spectra (FFT) to visualize noise reduction in frequency domain
    NFFT = 2^nextpow2(valid_samples);
    Y_d = fft(d_for_analysis, NFFT);
    Y_e = fft(e_for_analysis, NFFT);
    f_axis = Fs/2 * linspace(0, 1, NFFT/2 + 1);

    % figure;
    % plot(f_axis, 2*abs(Y_d(1:NFFT/2+1)));
    % hold on;
    % plot(f_axis, 2*abs(Y_e(1:NFFT/2+1)), 'r');
    % title('Frequency Spectrum of Noise Signals');
    % xlabel('Frequency (Hz)');
    % ylabel('Magnitude');
    % legend('Primary Noise (d(n))', 'Residual Error (e(n))');
    % grid on;
    % xlim([0 Fs/2]);
end
